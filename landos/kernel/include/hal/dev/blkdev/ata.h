/*
 * File: ata.h
 *
 * Essas rotinas fazem parte do projeto Sirius e são usadas aqui
 * para suporte à IDE/AHCI.
 * Suporte a disco, usado no kernel base.
 *
 * History: 
 *     2018 - Created by Nelson Cole.
 *     2019 - Revision by Fred Nora.
 *     ...
 */


#ifndef __ATA_H__
#define __ATA_H__


//
// Defines.
//



// Bus.
#define ATA_PRIMARY   0x00
#define ATA_SECONDARY 0x01

// Devices.
#define ATA_MASTER    0
#define ATA_SLAVE     1 
#define ATA_MASTER_DEV 0x00
#define ATA_SLAVE_DEV  0x01



// ATA type.
#define ATA_DEVICE_TYPE   0x00
#define ATAPI_DEVICE_TYPE 0x01

// Modo de transferência.
#define ATA_PIO_MODO  0 
#define ATA_DMA_MODO  1
#define ATA_LBA28     28
#define ATA_LBA48     48


#define FORCEPIO 1234



//#bugbug 
//Precisamos encontrar endereços válidos.
#define DMA_PHYS_ADDR0  0xa0000
#define DMA_PHYS_ADDR1  0xb0000
#define DMA_PHYS_ADDR2  0xb0000
#define DMA_PHYS_ADDR3  0xb0000 


//#bubbug usar definição do gramado.
#define PCI_CLASSE_MASS 1


// Controladores de unidades ATA.
#define ATA_IDE_CONTROLLER  0x1
#define ATA_RAID_CONTROLLER 0x4
#define ATA_AHCI_CONTROLLER 0x6

// Retorno da inicializacao PCI. 
#define PCI_MSG_ERROR       -1
#define PCI_MSG_AVALIABLE   0x80
#define PCI_MSG_SUCCESSFUL  0


// IO Space Legacy BARs IDE. 
#define ATA_IDE_BAR0  0x1F0  // Primary Command Block Base Address.
#define ATA_IDE_BAR1  0x3F6  // Primary Control Block Base Address.
#define ATA_IDE_BAR2  0x170  // Secondary Command Block Base Address.
#define ATA_IDE_BAR3  0x376  // Secondary Control Block Base Address.
#define ATA_IDE_BAR4  0      // Bus Master Base Address.
#define ATA_IDE_BAR5  0      // Usado pelo AHCI.


// ATA/ATAPI Command Set.

#define ATA_CMD_CFA_ERASE_SECTORS               0xC0
#define ATA_CMD_CFA REQUEST_EXTENDED_ERROR_CODE 0x03
#define ATA_CMD_CHECK_MEDIA_CARD_TYPE           0xD1
#define ATA_CMD_CHECK_POWER_MODE                0xE5
#define ATA_CMD_DEVICE_RESET                    0x08
#define ATA_CMD_EXECUTE_DEVICE_DIAGNOSTIC       0x90
#define ATA_CMD_FLUSH_CACHE                     0xE7
#define ATA_CMD_FLUSH_CACHE_EXT                 0xEA
#define ATA_CMD_IDENTIFY_DEVICE                 0xEC
#define ATA_CMD_IDENTIFY_PACKET_DEVICE          0xA1
#define ATA_CMD_PACKET                          0xA0
#define ATA_CMD_READ_BUFFER                     0xE4
#define ATA_CMD_READ_DMA                        0xC8
#define ATA_CMD_READ_DMA_EXT                    0x25
#define ATA_CMD_READ_SECTORS                    0x20
#define ATA_CMD_READ_SECTORS_EXT                0x24
#define ATA_CMD_WRITE_BUFFER                    0xE8
#define ATA_CMD_WRITE_DMA                       0xCA
#define ATA_CMD_WRITE_DMA_EXT                   0x35
#define ATA_CMD_WRITE_SECTORS                   0x30
#define ATA_CMD_WRITE_SECTORS_EXT               0x34

/*
 //#todo: esse deslocamento é em bytes,
 // mas usamos um ponteiro em short ... entao precisamos dividir por dois.
#define ATA_IDENT_DEVICETYPE   0
#define ATA_IDENT_CYLINDERS    2
#define ATA_IDENT_HEADS        6
#define ATA_IDENT_SECTORS      12
#define ATA_IDENT_SERIAL       20
#define ATA_IDENT_MODEL        54
#define ATA_IDENT_CAPABILITIES 98
#define ATA_IDENT_FIELDVALID   106
#define ATA_IDENT_MAX_LBA      120
#define ATA_IDENT_COMMANDSETS  164
#define ATA_IDENT_MAX_LBA_EXT  200
*/



// ATAPI descrito no SCSI.
#define ATAPI_CMD_READ  0xA8
#define ATAPI_CMD_EJECT 0x1B

//ATA bits de status control (alternativo).
#define ATA_SC_HOB  0x80    // High Order Byte.
#define ATA_SC_SRST 0x04    // Soft Reset.
#define ATA_SC_nINE 0x02    // INTRQ.


//ATA bits de status. 
#define ATA_SR_BSY  0x80    // Busy
#define ATA_SR_DRDY 0x40    // Device Ready
#define ATA_SR_DF   0x20    // Device Fault
#define ATA_SR_DSC  0x10    // Device Seek Complete
#define ATA_SR_DRQ  0x08    // Data Request
#define ATA_SR_SRST 0x04    // 
#define ATA_SR_IDX  0x02    // Index
#define ATA_SR_ERR  0x01    // Error

//ATA bits de errro após a leitura.
#define ATA_ER_BBK   0x80    // 
#define ATA_ER_UNC   0x40    //
#define ATA_ER_MC    0x20    //
#define ATA_ER_IDNF  0x10    //
#define ATA_ER_MCR   0x08    //
#define ATA_ER_ABRT  0x04    //
#define ATA_ER_TK0NF 0x02    //
#define ATA_ER_AMNF  0x01    //



//
// Registers
//

// See:
// https://wiki.osdev.org/ATA_PIO_Mode

// Read/Write PIO data bytes
#define ATA_REG_DATA      0x00
// R, Error Register,    Used to retrieve any error generated by the last ATA command executed.
#define ATA_REG_ERROR     0x01
// W, Features Register, Used to control command specific interface features.
#define ATA_REG_FEATURES  0x01
// Sector Count Register	Number of sectors to read/write (0 is a special value).
#define ATA_REG_SECCOUNT  0x02
// Sector Number Register (LBAlo)	This is CHS / LBA28 / LBA48 specific.
#define ATA_REG_LBA0      0x03
// Cylinder Low Register / (LBAmid)	Partial Disk Sector address.
#define ATA_REG_LBA1      0x04
// Cylinder High Register / (LBAhi)	Partial Disk Sector address.
#define ATA_REG_LBA2      0x05
// Drive/Head Register Used to select a drive and/or head. Supports extra address/flag bits.
#define ATA_REG_DEVSEL    0x06
// W, Command Register	Used to send ATA commands to the device.
#define ATA_REG_CMD       0x07
// R, Status Register	Used to read the current status.
#define ATA_REG_STATUS    0x07


/*
 #todo
 testar esse outros registradores.
#define ATA_REG_SECCOUNT1  0x08
#define ATA_REG_LBA3       0x09
#define ATA_REG_LBA4       0x0A
#define ATA_REG_LBA5       0x0B
#define ATA_REG_CONTROL    0x0C
#define ATA_REG_ALTSTATUS  0x0C
#define ATA_REG_DEVADDRESS 0x0D
*/

// ===========================================================

//
// Variables.
//

extern int ATAFlag;
extern unsigned short  *ata_identify_dev_buf;

extern unsigned char ata_record_dev;
extern unsigned char ata_record_channel;


// #important
// Qual é o canal e o dispositivo usado no momento
// pela rotina de leitura e escrita.
// See: config.h ata.c hdd.c

extern int g_current_ide_channel;  //primary or secondary.
extern int g_current_ide_device;   //master or slave

// #important
// Qual é o canal e o dispositivo usado no momento do boot 
// pela rotina de leitura e escrita.
// See: config.h ata.c hdd.c

extern int g_boottime_ide_channel;  //primary or secondary.
extern int g_boottime_ide_device;   //master or slave

/*
 * PCIDeviceATA:
 *     Estrutura de dispositivos pci para um disco ata.
 *     #bugbug: E se tivermos mais que um instalado ???
 *
 *     #importante
 *     Esssa é uma estrutura de dispositivos pci criada para o gramado, 
 * definida em pci.h
 */
extern struct pci_device_d *PCIDeviceATA;
// ...


/*
 * dev_nport:
 *     AHCI ports;
 */
struct dev_nport 
{ 
    unsigned char dev0;
    unsigned char dev1;
    unsigned char dev2;
    unsigned char dev3;
    unsigned char dev4;
    unsigned char dev5;
    unsigned char dev6;
    unsigned char dev7;
    unsigned char dev8;
    unsigned char dev9;
    unsigned char dev10;
    unsigned char dev11;
    unsigned char dev12;
    unsigned char dev13;
    unsigned char dev14;
    unsigned char dev15;
    unsigned char dev16;
    unsigned char dev17;
    unsigned char dev18;
    unsigned char dev19;
    unsigned char dev20;
    unsigned char dev21;
    unsigned char dev22;
    unsigned char dev23;
    unsigned char dev24;
    unsigned char dev25;
    unsigned char dev26;
    unsigned char dev27;
    unsigned char dev28;
    unsigned char dev29;
    unsigned char dev30;
    unsigned char dev31;
};
extern struct dev_nport  dev_nport;

// História:
//     Programação do ATA a partir do ICH5/9 e suporte a IDE legado.
//     ICH5 integraçao do SATA e suporte total ACPI 2.0.
//     ICH6 implementaram os controladores AHCI SATA pela primeira vez.

/*
 * ata:
 *     Estrutura para o controle de execução do programa.
 */ 

struct ata_d
{
    //int used;
    //int magic;

    uint8_t channel;  // Primary or secondary.
    uint8_t dev_num;  // Master or slave.

    uint8_t chip_control_type;
    uint8_t dev_type;  
    uint8_t access_type;
    uint8_t cmd_read_modo;
    uint32_t cmd_block_base_address;
    uint32_t ctrl_block_base_address;
    uint32_t bus_master_base_address;
    uint32_t ahci_base_address;
};
extern struct ata_d  ata;

/*
 * st_dev:
 * É uma estrutura para dispositivos de armazenamento.
 */

typedef struct st_dev 
{
    unsigned long dev_id;

    unsigned char  dev_nport;
    unsigned char  dev_type;            // ATA or ATAPI
    unsigned char  dev_num;
    unsigned char  dev_channel;
    unsigned char  dev_access;          // LBA28 or LBA48
    unsigned char  dev_modo_transfere;
    
    unsigned long dev_byte_per_sector;
    unsigned long dev_total_num_sector;
    
    // #??
    // 64bit type ?
    // Maybe we need some other type of representation here.

    unsigned long long dev_total_num_sector_lba48;

    unsigned long dev_size;
    
    // #test
    unsigned long _MaxLBA;
    unsigned long _MaxLBAExt;
    
    struct st_dev *next;

}st_dev;
// Defining the type.
typedef struct st_dev   st_dev_t;

//
// == Prototypes ==============================================
//

// current channel and device.
int ata_get_current_ide_channel(void);
int ata_get_current_ide_device(void);
void ata_set_current_ide_channel(int channel);
void ata_set_current_ide_device(int device);

// current channel and device during the boottime.
int ata_get_boottime_ide_channel(void);
int ata_get_boottime_ide_device(void);
void ata_set_boottime_ide_channel(int channel);
void ata_set_boottime_ide_device(int device);

int nport_ajuste(char nport);

void ide_mass_storage_initialize (void);

int ide_dev_init(char port);

void set_ata_addr(int channel);

int ide_identify_device(uint8_t nport);

void ata_wait(int val);

void ata_delay (void);

unsigned char ata_wait_not_busy (void);

unsigned char ata_wait_busy (void);

unsigned char ata_wait_no_drq (void);

unsigned char ata_wait_drq (void);

unsigned char ata_wait_irq (void);

unsigned char ata_status_read (void);

void ata_cmd_write(int cmd_val);

unsigned char ata_assert_dever(char nport);

void ata_pio_read ( void *buffer, int bytes);
void ata_pio_write ( void *buffer, int bytes);


void 
ide_dma_data ( 
    void *addr, 
    uint16_t byte_count, 
    uint8_t flg, 
    uint8_t nport );


void ide_dma_start (void);

void ide_dma_stop (void);

int ide_dma_read_status (void);


//ahci.c
//deletar.
//void ahci_mass_storage_init ();



//
// PCI support for disks.
//


// PCI READ.
uint32_t 
diskReadPCIConfigAddr ( 
    int bus, 
    int dev,
    int fun, 
    int offset );


// PCI WRITE.   
void 
diskWritePCIConfigAddr ( 
    int bus, 
    int dev,
    int fun, 
    int offset, 
    int data );


uint32_t diskPCIScanDevice ( int class );

int diskATAPCIConfigurationSpace ( struct pci_device_d *D );

void DeviceInterface_PrimaryIDE(void);
void DeviceInterface_SecondaryIDE(void);

int disk_ata_wait_irq (void);

void show_ide_info (void);

int 
ata_ioctl ( 
    int fd, 
    unsigned long request, 
    unsigned long arg );



//======================================================


//incluindo coisas que estavam em disk1.c

#define DISK1 1
#define DISK2 2
#define DISK3 3
#define DISK4 4


// gcc -Wall Defined but not used!
// base address 
static unsigned long ATA_BAR0;    // Primary Command Block Base Address
static unsigned long ATA_BAR1;    // Primary Control Block Base Address
static unsigned long ATA_BAR2;    // Secondary Command Block Base Address
static unsigned long ATA_BAR3;    // Secondary Control Block Base Address
static unsigned long ATA_BAR4;    // Legacy Bus Master Base Address
static unsigned long ATA_BAR5;    // AHCI Base Address / SATA Index Data Pair Base Address



//
// DMA support
//

// Commands dma 
#define dma_bus_start   1
#define dma_bus_stop    0
#define dma_bus_read    0
#define dma_bus_write   1

// Status dma
#define ide_dma_sr_err     0x02

// Registros bus master base address
#define ide_dma_reg_cmd     0x00
#define ide_dma_reg_status  0x02
#define ide_dma_reg_addr    0x04

// channel
#define ide_dma_primary     0x00
#define ide_dma_secundary   0x01


/* ide_dma_prdt: */

struct ide_dma_d 
{
    uint32_t addr;
    uint32_t len;
};
extern struct ide_dma_d  ide_dma_prdt[4];


// pci support
// #todo: Podemos mudar isso para pic.h, mas precisamos ver 
// se aceitará a tipagem.

#define CONFIG_ADDR(bus,device,fn,offset)\
                       (\
                       (((uint32_t)(bus) &0xff) << 16)|\
                       (((uint32_t)(device) &0x3f) << 11)|\
                       (((uint32_t)(fn) &0x07) << 8)|\
                       ((uint32_t)(offset) &0xfc)|0x80000000)




/*
 * ata_initialize:
 *     Inicializa o IDE e mostra informações sobre o disco.
 */

int ata_initialize ( int ataflag );

/*
 * ataDialog:
 *     Rotina de diálogo com o driver ATA.
 */
int 
ataDialog ( 
    int msg, 
    unsigned long long1, 
    unsigned long long2 );

#endif


